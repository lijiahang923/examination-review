根据您提供的PPT课件内容，我为您整理了一份详细的**《数据库系统与应用》考试复习资料**。这份资料涵盖了从基础理论到SQL Server操作，再到程序开发的各个重点。

---

# 数据库系统与应用（SQL Server 2008 + ADO.NET）复习大纲


## 第一章：数据库系统概论
**1. 基本概念**
*   **数据库DB (Database)**: 长期存储在计算机内、有组织的、可共享的大量数据的集合。
*   **数据库管理系统DBMS (Database Management System)**: 位于用户与操作系统之间的一层数据管理软件（如SQL Server, Oracle, MySQL）。主要功能包括数据定义、操纵、控制、维护。
*   **数据库系统DBS (Database System)**: **DBS = DB + DBMS + 应用程序 + DBA (数据库管理员)**。
    *   *考点关联*：DBS包含DBMS和DB。
*   **数据冗余**: 同一数据在数据库中多次重复存储，容易导致数据不一致。
*   **数据 (Data) 与 信息 (Information)**：数据是信息的载体，信息是数据的内涵（经过加工有用的知识）。

## 1. 核心概念辨析（必考名词解释）
### 1.1 数据 (Data) vs 信息 (Information)
*   **【专业术语】**
    *   **数据**：描述事物的符号记录。是信息的载体。
    *   **信息**：经过加工处理的、对决策有用的数据。是数据的内涵。
*   **【通俗译文】**
    *   **数据**：你体检表上的数字“37.5”。单纯看它只是个数字。
    *   **信息**：医生一看“37.5”，结合你是人类这个上下文，得出结论“你发低烧了”。这个结论就是信息。
*   **【考点深挖】**
*   * 考试常问二者关系：数据是原料，信息是成品。

 ### 1.2 数据库 (DB)
*   **【专业术语】** 长期存储在计算机内、有组织的、可共享的大量数据的集合。
*   **【通俗译文】** 一个**超级电子文件柜**。里面的文件不是乱塞的，而是分门别类整理好的，大家都能来看。
*   **【核心特征】**
    *   **永久存储**（断电不丢）。
    *   **有组织**（不是杂乱的txt，而是有结构的）。
    *   **可共享**（你我都可用）。

### 1.3 数据库管理系统 (DBMS) —— *重中之重*
*   **【专业术语】** 位于用户与操作系统之间的一层**系统软件**。负责科学地组织和存储数据、高效地获取和维护数据。
*   **【通俗译文】**
    *   如果DB是仓库，DBMS就是**仓库管理员**。
    *   你不能直接冲进仓库翻箱倒柜（不安全且效率低），你必须告诉管理员（写SQL语句），管理员帮你拿出来。
    *   常见的DBMS：SQL Server, MySQL, Oracle。
*   **【考点深挖】**
    *   DBMS是**软件**，不是硬件，也不是数据库本身。
    *   它两大功能：**定义数据**（建表）、**操纵数据**（增删改查）。

### 1.4 数据库系统 (DBS)
*   **【专业术语】** 在计算机系统中引入数据库后的系统构成。
*   **【公式】** **DBS = 硬件 + 软件(DBMS+OS) + 数据库(DB) + 人员(DBA)**
*   **【通俗译文】** 这是一个**全家桶**概念。
*   **【考点深挖】**
    *   **DBA（数据库管理员）**是DBS中最高级的用户，负责数据库的死活（设计、监控、维护）。

### 2. 数据管理技术的发展
*   **三个阶段**：人工管理 $\rightarrow$ 文件系统 $\rightarrow$ 数据库系统。
*   **数据库系统的特点**：数据结构化、数据共享性高、冗余度低、数据独立性高（逻辑/物理独立性）。
*   **人工管理阶段**：你把信息写在纸条上。缺点：容易丢，没法共享，找起来慢。
*   **文件系统阶段**：你用了电脑，存成 Word 或 Excel。缺点：数据冗余（张三的电话在“班级表”和“缴费表”里存了两份，改了一个，另一个忘了改，数据就不一致了）。
*   **数据库系统阶段（DBS）**：你用了一个专门的软件（如SQL Server）来管。特点：**数据结构化、共享性高、冗余度低**。

## 2. 数据管理技术的三个阶段（选择题常客）

| 阶段 | 数据存放 | 谁管数据 | 能否共享 | 独立性 |
| :--- | :--- | :--- | :--- | :--- |
| **人工管理** | 纸带/卡片 | 程序员自己写代码管 | 不共享(一组数据对应一个程序) | 差(程序改，数据得改) |
| **文件系统** | 磁盘文件 | 操作系统(OS) | 弱共享(文件是独立的) | 差(数据结构变，程序必须重写) |
| **数据库系统** | **数据库** | **DBMS** | **高共享** | **高(物理/逻辑独立)** |

*   **【通俗译文】**
    *   **人工管理**：我在纸上记账，你要看？不行，本子在我手里。（数据不保存，不共享）。
    *   **文件系统**：我存了个Excel，你存了个Word。虽然都在电脑里，但我要查你的数据很麻烦，而且如果我把Excel的列名改了，你的宏程序就报错了。（数据冗余大，独立性差）。
    *   **数据库系统**：所有数据丢进一个大池子，谁要谁取，格式改了也不影响你取数。（数据结构化，独立性高）。

---
### 3. 数据库体系结构 (三级模式 & 两级映像)
*   **三级模式**：
1.  **外模式 (External Schema) / 用户模式**
    *   **【解释】** **用户看到的**局部数据。
    *   **【例子】** 学生登录教务系统，只能看到“成绩表”和“课表”，看不到老师的“工资表”。这个局部视图就是外模式。
    *   **【特点】** 一个数据库可以有**很多个**外模式（因为用户有很多种）。
    *   **外模式 (用户模式)**：用户看到的局部数据视图。**用户看到的**。比如你是学生，你只能看到成绩表；老师能看到工资表。一个数据库可以有多个外模式。
2.  **模式 (Schema) / 逻辑模式 / 概念模式**
    *   **【解释】** **数据库的整体逻辑结构**。它是所有用户的公共视图。
    *   **【例子】** 教务系统的完整蓝图：包含学生表、老师表、课程表、工资表等所有表的定义。
    *   **【特点】** 一个数据库只有**一个**模式。
    *   **模式 (逻辑/概念模式)**：全体数据的逻辑结构，一个数据库只有一个。**数据库的整体逻辑**。这是数据库的“蓝图”，比如规定学生表有学号、姓名。**一个数据库只有一个模式**。
3.  **内模式 (Internal Schema) / 存储模式**
    *   **【解释】** **数据在硬盘上怎么存的**。
    *   **【例子】** 数据是存在C盘还是D盘？是用B+树索引还是Hash索引？数据是压缩存还是加密存？
    *   **【特点】** 一个数据库只有**一个**内模式。
    *   **内模式 (存储/物理模式)**：数据在物理存储介质上的存放方式。**存在硬盘上的**。数据具体存在哪个磁道、用什么格式存。**一个数据库只有一个内模式**

### 3.2 两级映像（实现数据独立性）
**核心思想**：**中间层（模式）不变，两头变了也没事。**
*   **两级映像**：
    *   **外模式/模式映像** $\rightarrow$ 保证**逻辑独立性** (逻辑结构改变，程序不用改)（表结构变了，你的程序不用改）。
    *   **场景**：数据库加了一张新表（模式变了）。
    *   **作用**：DBA只需要修改这个映像，告诉系统“原来的外模式怎么映射到新模式”，**用户的应用程序代码不用修改**。
    *   **模式/内模式映像** $\rightarrow$ 保证**物理独立性** (存储结构改变，逻辑结构不用改)（存硬盘的位置变了，表结构不用改）
    *   **场景**：数据库从C盘搬到了D盘，或者换了更快的存储结构（内模式变了）。
    *   **作用**：DBA修改这个映像，**模式（逻辑结构）不需要变**，程序员完全无感知。

---

 *   **概念模型**：按用户观点建模，常用 **E-R图 (实体-联系图)**。
1.  **现实 $\to$ 概念模型（E-R图）**：
    *   **实体**：客观存在的东西（矩形），如“学生”。
    *   **属性**：实体的特征（椭圆），如“学号”。
    *   **联系**：实体间的关系（菱形），如“选课”。
    **实体-联系模型 (E-R模型)**:
    *   **联系类型**：  1:1 (一对一)、1:n (一对多)、m:n (多对多)。
        *   **1:1**（班长和班级）。
        *   **1:n**（班级和学生，一个班有多个学生）。
        *   **m:n**（学生和课程，一个学生选多门课，一门课被多人选）。

2.  **概念模型 $\to$ 逻辑模型（关系模型）**：

1.  **现实世界**：客观存在的事物（比如：现实中的班长张三）。
2.  **信息世界**：人脑对现实的抽象（比如：E-R图中的“学生”实体）。
3.  **机器世界**：电脑里的数据（比如：数据库里的 `Student` 表）。

*   **【考点】** **概念模型**对应信息世界（人看的）；**逻辑模型/物理模型**对应机器世界（机器看的）。
*   把E-R图变成**二维表**。这就是目前最主流的**关系模型**。
*   **概念模型**: 按用户观点建模，主要用于数据库设计（如E-R图）。
*   **逻辑模型**: 按计算机系统观点建模，主要包括：**层次模型**（树状）、**网状模型**（网状）、**关系模型**（二维表）。
    *   *考点关联*：目前应用最广泛的是**关系数据库**。
*   **逻辑/数据模型**：
    *   **层次模型** (树状结构)、**网状模型** (图状结构)。
    *   **关系模型** (二维表结构，最常用)。
    *   **面向对象模型**。

## 🚀 第四模块：数据库设计实战 (E-R图与转化)

这部分通常是试卷中的“画图题”或“设计题”，分值很高（约10-15分）。

### 1. E-R图绘制规范 (不丢分的关键)
*   **实体 (Entity)**：用**矩形**表示。 (例如：学生、课程)
*   **属性 (Attribute)**：用**椭圆**表示，主键属性名下画**下划线**。
*   **联系 (Relationship)**：用**菱形**表示，并用线段连接相关实体。
    *   **必须标注联系类型**：在线段旁标上 `1`、`n` 或 `m`。
    *   **联系也可以有属性**：例如“选课”联系，属性是“成绩”。

### 2. 常见联系类型的转换规则 (必考)
设计完E-R图后，通常需要将其转换为关系模式（表结构）。

*   **1:1 联系 (一对一)**
    *   *规则*：可以转换为一个独立的表，也可以将联系合并到**任意一端**的实体表中。
    *   *推荐*：合并到任意一端，将另一端的主键作为外键加入。
    *   **【解释】** A中的一个只能对应B中的一个，反之亦然。
    *   **【例子】** `班级` 和 `班长`。一个班级只有一个班长，一个班长只管一个班级。
    *   **【E-R画法】** 菱形两边的线段旁分别标 `1` 和 `1`。
*   **1:n 联系 (一对多)**
    *   *规则*：**千万不要**为联系单独建表（虽然可以，但不仅浪费空间，而且效率低）。
    *   *标准做法*：将`1`端的主键，加入到`n`端的表中作为**外键**。
    *   *例子*：班级(1) - 学生(n)。在“学生表”中增加“班级ID”作为外键。
    *   **【解释】** A中的一个可以对应B中的多个，但B中的一个只能对应A中的一个。
    *   **【例子】** `班级` 和 `学生`。一个班级有N个学生，但一个学生只属于1个班级。
    *   **【E-R画法】** 班级那边标 `1`，学生那边标 `n`。
*   **m:n 联系 (多对多)**
    *   *规则*：**必须**转换为一个独立的表（联系表）。
    *   *表结构*：{ 一端主键 + 另一端主键 + 联系的属性 }。
    *   *主键*：(一端主键, 另一端主键) 的组合。
    *   *例子*：学生(m) - 课程(n)。新建表 `SC(Sno, Cno, Grade)`，主键是 `(Sno, Cno)`。
    *   **【解释】** A中的一个对应B中多个，B中一个也对应A中多个。**双向海王**。
    *   **【例子】** `学生` 和 `课程`。一个学生选多门课，一门课被多个人选。
    *   **【E-R画法】** 学生那边标 `m`，课程那边标 `n`。
    *   **【注意】** m:n 的联系通常也有**属性**（比如“成绩”，它既不属于学生也不属于课程，属于“选课”这个动作），画图时要挂在菱形上。

| 联系类型 | 转换规则 (背诵) | 例子 |
| :--- | :--- | :--- |
| **实体** | 每个实体转成一个表。 | 学生表(学号, 姓名) |
| **1:1 联系** | 可以转成独立表，也可以**合并**到任意一端。 | 班长与班级。把班长ID加到班级表里，或者把班级ID加到班长表里。 |
| **1:n 联系** | **不单独建表**。把“1”端的主键，加到“n”端的表里作为外键。 | 班级(1) - 学生(n)。把“班级ID”加到“学生表”里。 |
| **m:n 联系** | **必须单独建表**。新表包含两端的主键 + 联系的属性。 | 学生(m) - 课程(n)。新建“选课表”(**学号, 课程号**, 成绩)。 |

*   **【避坑指南】**：很多同学看到 1:n 也要单独建个联系表，这是错的！虽然也能用，但会增加冗余和查询复杂度，扣分点。**只有 m:n 才必须建新表。**

---

## 2. E-R图 (Entity-Relationship Diagram) —— *画图题核心*

### 2.1 三大要素
*   **实体**：矩形 $\square$。
*   **属性**：椭圆 $\circ$。（主键加下划线）。
*   **联系**：菱形 $\diamond$。（里面写联系名，如“选修”）。

### 2.2 难点：联系的类型与属性
*   **联系类型**：一定要在连线上标明 **1:1**、**1:n** 或 **m:n**。
*   **联系的属性**：有些属性不属于任何一方实体，而属于“关系”本身。
    *   *例子*：学生选修课程，“**成绩**”这个属性，既不属于学生（没选课哪来成绩），也不属于课程（没学生考哪来成绩），它属于“选修”这个联系。画图时，**成绩**要连在**菱形**上。

### 3. 设计题解题套路
**题目**：设计一个图书借阅系统。实体有：图书(书号, 书名)，读者(卡号, 姓名)。一个读者可以借多本书，一本书可以被多个读者借过。借阅时记录借阅日期。
**步骤**：
1.  **画图**：画出“图书”和“读者”矩形，“借阅”菱形。
2.  **定型**：读者与图书是 **m:n** 关系。
3.  **属性**：“借阅日期”是“借阅”这个联系的属性，挂在菱形上。
4.  **转化**：姓名或者书名有可能重复
    *   表1：图书(<u>书号</u>, 书名)
    *   表2：读者(<u>卡号</u>, 姓名)
    *   表3 (联系表)：借阅(<u>卡号, 书号, 借阅日期</u>) —— *注意：如果允许同一人多次借同一本书，主键可能需要包含时间*。



# 🎯 章节实战演练 (Self-Check)

### 一、 选择题
1.  **题目**：在关系模型中，实现“实体完整性”约束是通过定义（ ）。
    *   A. 外键
    *   B. 主键
    *   C. 用户自定义约束
    *   D. 索引
    *   **【解析】** 选 **B**。实体完整性 = 主键不为空且唯一。

2.  **题目**：有一个关系：学生(学号, 姓名, 系别)，规定“学号”的值域是8位数字，这属于（ ）。
    *   A. 实体完整性
    *   B. 参照完整性
    *   C. 用户定义完整性
    *   D. 域完整性
    *   **【解析】** 选 **C**。这是针对具体数据的自定义规矩。

3.  **题目**：E-R图设计属于数据库设计的哪个阶段？（ ）。
    *   A. 需求分析
    *   B. 概念结构设计
    *   C. 逻辑结构设计
    *   D. 物理结构设计
    *   **【解析】** 选 **B**。概念设计 = E-R图；逻辑设计 = 转成表。

### 二、 综合设计题 (必练)

**题目背景**：
设计一个“医院管理系统”。
*   **科室**：有科室号、科室名。
*   **医生**：有工号、姓名、职称。一个科室有多个医生，一个医生只属于一个科室。
*   **病人**：有病历号、姓名。
*   **看病**：一个医生可以给多个病人看病，一个病人可以找多个医生看病。看病时要记录**诊断时间**和**诊断结果**。

**问题 1：画出E-R图。**
*   **【思路】**
    *   实体：科室、医生、病人。
    *   联系1：科室 - 医生（1:n）。联系名：所属。
    *   联系2：医生 - 病人（m:n）。联系名：看病。
    *   属性：**注意！** “诊断时间”和“诊断结果”必须挂在“看病”这个菱形上。

**问题 2：将E-R图转换为关系模式（表结构）。**
*   **【答案】**
    1.  **科室表** (<u>科室号</u>, 科室名)
    2.  **医生表** (<u>工号</u>, 姓名, 职称, *科室号*) $\to$ *注意：1:n联系，把科室号放进医生表做外键。*
    3.  **病人表** (<u>病历号</u>, 姓名)
    4.  **看病表** (<u>工号, 病历号, 诊断时间</u>, 诊断结果) $\to$ *注意：m:n联系单独建表，主键是组合键。如果一个病人同一天找同一个医生多次，主键可能还需要包含时间。*

---

### 💡 复习小贴士
1.  **搞定关系代数**：尤其是“除法”的含义（查询全部...），一定要看懂例子。
2.  **E-R图转表**：记住口诀“**1对1随你便，1对多跟多走，多对多单建表**”。
3.  **区分阶段**：E-R图是概念阶段，表结构是逻辑阶段，索引是物理阶段。


---

# 🎯 模拟实战演练 (自我检验)

### 一、 选择题挑战
1.  **题目**：数据库系统中，物理存储结构的变化不影响用户的应用程序，这体现了数据库的（ ）。
    *   A. 物理独立性
    *   B. 逻辑独立性
    *   C. 分布独立性
    *   D. 事务一致性
    *   **【解析】** 选 **A**。存储变了程序不变 $\to$ 物理独立性。如果是表结构加了一列程序不变 $\to$ 逻辑独立性。

2.  **题目**：下列关于E-R图的说法，错误的是（ ）。
    *   A. 矩形表示实体
    *   B. 菱形表示联系
    *   C. 椭圆表示属性
    *   D. 联系不能拥有属性
    *   **【解析】** 选 **D**。多对多联系（如选课）经常有属性（如成绩），这个属性必须画在联系（菱形）上。

### 二、 填空题挑战
1.  数据管理技术经历了人工管理、__________ 和数据库系统三个阶段。
    *   **【答案】** 文件系统
2.  一个学生可以同时借阅多本图书，一本图书也可以被多个学生借阅，学生和图书之间是 __________ 的联系。
    *   **【答案】** 多对多 (m:n)

### 三、 简答/设计题挑战
**题目**：请设计“工厂管理”的E-R图逻辑。
*   **厂长** 管理 **工厂** （一个厂长管一个厂，一个厂有一个厂长）。
*   **工厂** 拥有 **工人** （一个厂有多个工人，工人只属于一个厂）。
*   **工人** 生产 **产品** （工人生产多种产品，产品由多个工人生产，记录生产数量）。

**【解题思路】**：
1.  **找实体**：厂长、工厂、工人、产品。（画4个矩形）。
2.  **找关系**：
    *   厂长 - 工厂：**1:1**。
    *   工厂 - 工人：**1:n** （工厂是1，工人是n）。
    *   工人 - 产品：**m:n**。
3.  **找关系属性**：“生产数量”应该挂在“工人”和“产品”中间的那个菱形（生产）上。

---

# 🚀 复习建议
1.  **不要死背定义**：试着用我上面的“通俗译文”去理解，理解了自然能选对。
2.  **重点关注图表**：把E-R图的三种符号和三种联系画一遍，这是必考分。
3.  **区分三个模式**：记住 **外模式=用户看，模式=全局逻辑，内模式=硬盘存**。
4.  **区分两个独立性**：物理独立性（存哪里变了没事），逻辑独立性（表结构变了没事）。



---

## 第二章：关系数据库理论

### 1.1 关系 (Relation) 与 表 (Table)
*   **【专业术语】** 关系是笛卡尔积的有限子集。一个关系对应通常说的一张表。
*   **【通俗译文】** “关系”在数学上叫集合，在电脑里就是**一张二维表**。
    *   **元组 (Tuple)** = 表中的**一行**（一条记录，比如“张三, 男, 20岁”）。
    *   **属性 (Attribute)** = 表中的**一列**（一个字段，比如“姓名”）。
    *   **域 (Domain)** = 属性的取值范围（比如“性别”列只能填“男/女”，不能填“未知”）。
    *   **分量** = 元组中的一个值（比如“张三”）。

## 3. 逻辑模型：关系模型 (Relational Model)

当今世界最主流的模型（SQL Server, MySQL, Oracle 都是关系型）。

### 3.1 基本术语对照表（秒懂版）

| 关系术语 | 通俗叫法 | 解释 |
| :--- | :--- | :--- |
| **关系 (Relation)** | **表 (Table)** | 一张二维表。 |
| **元组 (Tuple)** | **行 (Row) / 记录** | 表里的一行数据（比如张三的所有信息）。 |
| **属性 (Attribute)** | **列 (Column) / 字段** | 表里的一列（比如“姓名”列）。 |
| **域 (Domain)** | **取值范围** | 这一列能填什么值（比如性别只能填“男/女”）。 |
| **主码 (Primary Key)** | **主键** | 身份证号。唯一标识一个人，不能重复，不能空。 |
| **外码 (Foreign Key)** | **外键** | 引用别人的主键。比如在“成绩表”里写了“学号”，这个学号就是外键，它指向“学生表”。 |

### 3.2 关系的规范性（必考）
*   **原子性**：关系表中的每一个格子（分量）必须是**不可再分**的数据项。
    *   *错误例子*：有一列叫“家庭成员”，里面填了“爸爸、妈妈、妹妹”。（这就不行，得拆开）。
---

### 2. 范式理论 (Normalization) —— 设计题必考
如果设计题让你判断范式或优化表结构，请套用以下公式：

*   **第一范式 (1NF)**：**属性不可分**。
    *   *错误示例*：字段“联系方式”里填了“电话:123, 邮箱:a@b.com”。
    *   *修正*：拆分成“电话”列和“邮箱”列。
*   **第二范式 (2NF)**：在1NF基础上，**消除非主属性对主码的部分函数依赖**（主要针对联合主键）。
    *   *口诀*：非主属性必须依赖于**整个**主键，而不能只依赖主键的一部分。
    *   *错误示例*：表(学号, 课程号, 分数, 学生姓名)。主键是(学号, 课程号)。但“学生姓名”只依赖于“学号”。
    *   *修正*：拆分成 (学号, 课程号, 分数) 和 (学号, 学生姓名)。
*   **第三范式 (3NF)**：在2NF基础上，**消除非主属性对主码的传递函数依赖**。
    *   *口诀*：非主属性之间不能有依赖关系（A $\to$ B $\to$ C）。
    *   *错误示例*：表(学号, 系名, 系主任)。主键是学号。学号 $\to$ 系名，系名 $\to$ 系主任。
    *   *修正*：拆表。

*   **基本术语**：关系(表)、元组(行)、属性(列)、域(取值范围)。

**1. 关系术语**
*   **超键 (Super Key)**：能唯一标识元组的属性集（可能包含多余属性）。
    *   *例子*：(学号, 姓名) 是超键，因为学号唯一，加上姓名也唯一。
*   **候选键 (Candidate Key)**：**最小**的超键（没有多余属性）。
    *   *例子*：(学号) 是候选键。如果一个表里(身份证号)也是唯一的，那它也是候选键。
*   **主键 (Primary Key)**：从候选键中选出一个作为主要标识符。
    *   *特点*：非空、唯一。
*   **主属性 vs 非主属性**：包含在**任何一个**候选键中的属性称为主属性；不包含在任何候选键中的称为非主属性。
*   **键 (Key)**：
    *   **候选键**：能唯一标识元组的属性组。
    *   **主键 (Primary Key)**：被选中的候选键，唯一且非空。
    *   **外键 (Foreign Key)**：引用其他表的主键，用于建立联系。
*   **主码 (Primary Key)**: 能唯一标识实体的属性或属性组。
*   **外码 (Foreign Key)**: 引用其他关系的主码，用于建立表与表之间的联系。
*   **域 (Domain)**: 属性的取值范围。
### 1. 关系模型的规矩（第3章重点）
在关系数据库里，数据就是一张张二维表。
*   **主键 (Primary Key, PK)**：能**唯一**标识一行记录的列。比如身份证号。（**实体完整性**：主键不能空，不能重复）。
*   **外键 (Foreign Key, FK)**：这一列的数据引用了另一张表的主键。比如成绩表里的“学号”引用学生表的“学号”。（**参照完整性**：外键要么为空，要么必须是存在的学号）。
### 1.2 键/码 (Key) —— *考试必考，概念极易混淆*

| 术语 | 定义 (专业) | 人话解释 (通俗) | 例子 |
| :--- | :--- | :--- | :--- |
| **候选键** (Candidate Key) | 能唯一标识元组的**最小**属性集。 | 有资格当老大的属性。既能区分每个人，又不多余。 | 学号、身份证号。 |
| **主键** (Primary Key) | 从候选键中选定一个作为记录的唯一标识。 | 被选中的老大。一张表只能有一个。 | **学号** (选它做主键)。 |
| **主属性** | 包含在任何一个候选键中的属性。 | 候选老大的组成部分。 | 学号、身份证号。 |
| **非主属性** | 不包含在任何候选键中的属性。 | 普通群众，没资格当老大。 | 姓名、年龄。 |
| **外键** (Foreign Key) | 本关系中的属性是另一个关系的主键。 | **外交官**。我在A表里是普通列，但在B表里我是主键。 | 成绩表里的“学号”。 |

*   **【考点深挖】**
    *   主键可以由**多个列**组成（联合主键）。比如“选课表”，只有 `(学号, 课程号)` 合在一起才能确定唯一的成绩，单看学号或课程号都不行。

**2. 完整性约束 (重点)**
*   **实体完整性**: 主码不能为空，且不能重复。
*   **参照完整性**: 外码必须是另一个表存在的主码值或为空。
*   **用户定义完整性**: 针对具体数据的约束（如年龄>0，性别只能是男/女）。

## 2. 关系的完整性约束 (Integrity Constraints)

这是保证数据库不变成“垃圾堆”的三大铁律。
*   **完整性约束 (三类)**：
    1.  **实体完整性**：主键不能为空。
    2.  **参照完整性**：外键必须取空值或有效的主键值。
    3.  **用户定义完整性**：针对具体数据的约束 (如年龄>0)。
### 2.1 实体完整性 (Entity Integrity)
*   **【规则】** 主键的值**不能为空 (NOT NULL)**，且**不能重复**。
*   **【人话】** 每个人必须有身份证号，而且不能是黑户，也不能重号。

### 2.2 参照完整性 (Referential Integrity)
*   **【规则】** 外键的值，要么是**空值 (NULL)**，要么必须是**被引用表中已经存在的主键值**。
*   **【人话】** 成绩表里有个学号写着“9527”。那么学生表里**必须**真有一个学号叫“9527”的人。你不能给一个不存在的学生录入成绩。

### 2.3 用户定义完整性 (User-defined Integrity)
*   **【规则】** 针对具体数据的约束。
*   **【人话】** 自定义的规矩。比如：年龄不能是负数，性别只能是男或女。

## 3. 关系代数 (Relational Algebra) —— *计算题/填空题难点*

这部分是SQL语言的数学原型，考试常考“看符号写结果”或“把中文需求转成代数式”。

*   **关系代数**：
    *   **传统集合运算**：并($\cup$)、交($\cap$)、差($-$)、笛卡尔积($\times$)。
    *   **专门关系运算**：选择($\sigma$，选行)、投影($\pi$，选列)、连接($\bowtie$，多表结合)、除($\div$)。

### 3.1 传统集合运算（横向操作）
*   **并 ($\cup$)**：表A + 表B（去重）。
*   **交 ($\cap$)**：表A和表B共有的行。
*   **差 ($-$)**：在表A中但不在表B中的行。（例如：查询**没有**选课的学生 = 所有学生 - 选了课的学生）。
*   **笛卡尔积 ($\times$)**：**暴力组合**。表A有3行，表B有2行，结果有 $3 \times 2 = 6$ 行。列数相加，行数相乘。

**3. 关系代数 (图形题考点)**
*   **并 (Union)**: 两个关系合并。
*   **交 (Intersection)**: 两个关系共有的部分。
*   **笛卡尔积 (Cartesian Product)**: 两个关系所有元组的排列组合（列数相加，行数相乘）。
*   **连接 (Join)**: 从两个关系的笛卡尔积中选取属性间满足一定条件的元组。
    *   *自然连接*: 去掉重复列的等值连接。

### 3.2 专门关系运算（纵向+横向操作）—— *重难点*

**★ 难点突破：关系代数**
考试可能会让你看符号写结果，其实就是集合运算：
*   **选择 ($\sigma$)**：**挑行**。比如挑出“性别=男”的行。
*   **投影 ($\pi$)**：**挑列**。比如只看“姓名”和“成绩”这两列。
*   **连接 ($\bowtie$)**：**拼表**。把两张表拼在一起，通常是根据共同的列（如学号相等）拼起来。
*   **除法 ($\div$)**：**找“全部”**。比如查询“选修了**所有**课程的学生”。


### 3. 关系代数的高级运算
考试中可能会出现看图写运算结果，或者将SQL翻译成关系代数。
*   **除法 ($\div$)**：通常用于解决“**查询所有...**”的问题。
    *   *语义*：R $\div$ S 的结果是，R中X属性的值，与S中Y属性的所有值都对应。
    *   *例子*：查询选修了**所有**课程的学生。 (选课表 $\div$ 课程表)。
*   **自然连接 ($\bowtie$) vs 等值连接**：
    *   等值连接保留重复列（如 Student.Sno 和 SC.Sno 同时存在）。
    *   自然连接**自动去掉**重复列，且要求列名相同。

1.  **选择 ($\sigma$, Select)** —— **挑行**
    *   **【定义】** 选出满足条件的行。
    *   **【例子】** $\sigma_{年龄>20}(学生表)$ $\to$ 挑出所有大于20岁的学生。

2.  **投影 ($\pi$, Project)** —— **挑列**
    *   **【定义】** 选出指定的列，并自动去重。
    *   **【例子】** $\pi_{姓名, 系别}(学生表)$ $\to$ 只看姓名和系别这两列。

3.  **连接 ($\bowtie$, Join)** —— **拼表**
    *   **等值连接**：两个表某些列的值相等，就拼在一起。
    *   **自然连接 (Natural Join)**：**最常用**。自动把两个表中**同名**的列进行等值连接，并且**去掉重复的列**。
        *   *场景*：学生表(学号, 姓名) $\bowtie$ 成绩表(学号, 分数) $\to$ 结果表(学号, 姓名, 分数)。注意“学号”只出现一次。
    *   **外连接 (Outer Join)**：
        *   **左外连接** (Left Join)：左边的表全保留，右边匹配不上的填NULL。

4.  **除法 ($\div$, Division)** —— **找“全部”**
    *   **【语义】** 查询做到了**某集合中所有事情**的对象。
    *   **【标志词】** 题目中出现“**全部**”、“**所有**”。
    *   **【例子】** $R(学生, 课程) \div S(课程)$。
        *   如果S里是{数学, 英语}。
        *   结果就是：既选了数学、**又**选了英语的学生。
        *   *口诀*：像除法一样，约掉公共部分（课程），剩下的就是结果（学生）。


---
## 第二部分：数据库设计 (第5章)

### 1. 设计步骤 (6个阶段)
1.  **规划**：可行性分析。
2.  **需求分析**：收集需求，产出数据流图(DFD)、数据字典(DD)。
3.  **概念结构设计**：**E-R图** (关键步骤，独立于DBMS)。
4.  **逻辑结构设计**：将E-R图转换为关系模式 (表)，进行规范化。
    *   *转换规则*：1:1 (属性并入任一方)、1:n (1端主键放入n端作外键)、m:n (新建一张表，包含两端主键)。
5.  **物理结构设计**：索引设计、存储路径选择。
6.  **实施与维护**：建库、载入数据、试运行。

设计数据库不是拍脑袋，有6个步骤（**口诀：需概逻物实运**）：
1.  **需求分析**：搞清楚用户要干嘛（画数据流图）。
2.  **概念结构设计**：画 **E-R图**（这是最关键的一步）。
3.  **逻辑结构设计**：把E-R图转成表（关系模式）。
    *   *转化口诀*：1:1和1:n的联系，不单独建表，把id放到另一边；**m:n的联系，必须单独建一张新表**。
4.  **物理结构设计**：考虑存取路径、索引。
5.  **实施**：写代码建库。
6.  **运行维护**。

---

## 第三部分：SQL Server 管理与操作 (第6-8, 10章)

# 第6章：SQL Server 2008 概述 (认识工具)

这章是入门，主要是认识你的“工作台”。

## 1. SQL Server 的体系结构
*   **【专业术语】** C/S 架构（Client/Server）。
    *   **服务器端**：负责数据存储、处理请求（Database Engine）。
    *   **客户端**：负责发送请求、显示结果（如 SSMS）。
*   **【通俗译文】**
    *   **服务器**就是“后厨”，负责做菜（处理数据）。
    *   **客户端**就是“服务员”或“菜单”，你通过它点菜（发指令），后厨做好了端给你。
    *   你电脑上装的 **SSMS (SQL Server Management Studio)** 就是那个菜单界面。

### 1. 系统数据库
*   **master**：记录所有系统级信息 (登录、配置)，最重要。
*   **model**：创建新数据库的模板。
*   **msdb**：用于代理服务 (Agent)，调度作业和报警。
*   **tempdb**：临时工作区，重启后重建。


1.  **系统数据库（必须背）**：
    *   **master**：老大，记录所有系统级信息（登录名、配置）。没了它系统瘫痪。
    *   **model**：模具，创建新数据库时都照着它复制一份。
    *   **msdb**：管家，负责代理服务、作业调度、备份历史。
    *   **tempdb**：草稿纸，存临时数据，**每次重启都会被清空重建**。

## 2. 四大系统数据库 (System Databases) —— *死记硬背必考点*
SQL Server 安装好后，自带了4个“不能动”的数据库，它们维持着系统的运行。

| 数据库名 | 作用 (专业) | 作用 (通俗) | 考试要点 |
| :--- | :--- | :--- | :--- |
| **master** | 记录SQL Server实例的所有系统级信息（登录账户、配置设置等）。 | **大脑/总管**。如果它坏了，整个数据库软件都启动不了。 | **最重要**，记录系统信息。 |
| **model** | 创建新数据库的模板。 | **模具**。你新建一个数据库，系统其实是把model复制了一份给你。 | 修改它会影响以后新建的所有库。 |
| **msdb** | 供SQL Server代理服务调度警报、作业和记录操作员。 | **管家/闹钟**。负责定时任务（比如每天凌晨2点自动备份）。 | 只有用到定时任务时才关键。 |
| **tempdb** | 保存临时对象或中间结果集。 | **草稿纸**。每次重启SQL Server，这里面的东西就被**清空重建**。 | **断电数据丢失**。 |

---

2.  **文件扩展名**：
    *   主数据文件：**.mdf**
    *   次要数据文件：**.ndf**
    *   日志文件：**.ldf** （记录操作流水账，用于恢复）
## 1. 数据库文件组成
*   **【专业术语】**
    1.  **主数据文件 (.mdf)**：Primary Data File。存放数据和启动信息。**（且仅有一个）**
    2.  **次要数据文件 (.ndf)**：Secondary Data File。存放主文件存不下的数据。（可选，可以有多个）。
    3.  **事务日志文件 (.ldf)**：Log Data File。存放恢复数据库所需的日志信息。**（至少有一个）**。
*   **【通俗译文】**
    *   **.mdf** 是**日记本正本**，写正事的。
    *   **.ndf** 是**日记本续本**，正本写不下了才用它。
    *   **.ldf** 是**流水账**，记录了“几点几分你修改了哪一行”。如果断电了，系统重启时就靠这个流水账把没保存完的数据恢复回来。

### 2. 数据库与表管理 (T-SQL)
*   **创建数据库**：`CREATE DATABASE` (含 `ON PRIMARY` 数据文件.mdf, `LOG ON` 日志文件.ldf)。
*   **创建表**：`CREATE TABLE`。
*   **修改表**：`ALTER TABLE` (ADD, DROP COLUMN, ALTER COLUMN)。
*   **删除表**：`DROP TABLE`。
*   **数据类型**：`int`, `char` (定长), `varchar` (变长), `datetime`, `money` 等。

## 2. 创建表的 T-SQL (默写级)
*   **必背结构**：列名 + 类型 + 约束。
```sql
CREATE TABLE Student (
    Sno CHAR(10) PRIMARY KEY,          -- 设置主键
    Sname VARCHAR(20) NOT NULL,        -- 非空
    Sage INT DEFAULT 18,               -- 默认值
    Ssex CHAR(2) CHECK(Ssex IN ('男','女')) -- 检查约束
);
```
## 2. 常用管理操作 (重点T-SQL语句)

### 2.1 创建数据库
```sql
CREATE DATABASE MySchool  -- 数据库名
ON PRIMARY (
    NAME = 'MySchool_Data', -- 逻辑名(给SQL Server看的)
    FILENAME = 'D:\Data\MySchool.mdf', -- 物理路径(给操作系统看的)
    SIZE = 5MB,             -- 初始大小
    FILEGROWTH = 1MB        -- 满了以后每次长多大
)
LOG ON (
    NAME = 'MySchool_Log',
    FILENAME = 'D:\Data\MySchool_log.ldf',
    SIZE = 1MB
);
```

# 第8章：表管理 (造房子)

这章讲怎么建表，以及核心的数据类型。

## 1. 常用数据类型 (必考辨析)

| 类型 | 含义 | 区别与考点 |
| :--- | :--- | :--- |
| **int** | 整数 | 没什么好说的，存人数、年龄。 |
| **char(n)** | **定长**字符串 | **死板**。`char(10)`存了"abc"，它也会占10个空间，后面补空格。**适合存身份证、手机号**。 |
| **varchar(n)** | **变长**字符串 | **灵活**。`varchar(10)`存"abc"，它就只占3个字符空间。**适合存姓名、地址**。 |
| **datetime** | 日期时间 | 格式如 `2023-11-26 12:30:00`。 |
| **float / decimal** | 小数 | `decimal(18, 2)` 表示总共18位，其中小数占2位（常用于存**钱**）。 |
---


### 3. 约束与索引
*   **五大约束**：
    *   `PRIMARY KEY` (主键)
    *   `FOREIGN KEY` (外键)
    *   `UNIQUE` (唯一)
    *   `CHECK` (检查条件)
    *   `DEFAULT` (默认值)
    *   `NOT NULL` (非空)
*   **索引 (Index)**：
    *   **聚集索引 (Clustered)**：物理顺序与索引顺序一致，一张表只能有一个 (通常是主键)。
    *   **非聚集索引 (Non-clustered)**：逻辑有序，物理无序，一张表可有多个。
    *   语法：`CREATE INDEX` / `DROP INDEX`。

### 4. 安全管理
*   **验证模式**：Windows身份验证 (更安全)、混合模式 (SQL账号+Windows账号)。
*   **层级**：登录名 (服务器级) $\rightarrow$ 用户 (数据库级) $\rightarrow$ 权限 (对象级)。

# 第10章：安全管理 (门卫与安保)

这章解决“谁能进来”和“谁能干什么”的问题。

## 1. 三层安全防线 (考点：顺序不能乱)

1.  **服务器级 (登录名 Login)**：
    *   **【通俗】** **进大门**的卡。你得先能连上 SQL Server 软件。
    *   **【验证模式】**：
        *   **Windows 身份验证**：你只要登录了Windows系统，就能进SQL Server（不需要输密码，信任你）。**最安全**。
        *   **混合模式**：既可以用Windows账号，也可以用SQL账号（比如著名的 **sa** 账号）登录。
2.  **数据库级 (用户 User)**：
    *   **【通俗】** **进房间**的钥匙。你进了大门（服务器），但想进“教务处房间”（具体某个数据库），得有这个房间的用户身份。
    *   **【关系】** 一个登录名(Login) 可以映射到多个数据库中成为用户(User)。
3.  **对象级 (权限 Permission)**：
    *   **【通俗】** **开柜子**的权利。进了房间，你能不能看这张表？能不能改那张表？


3.  **安全机制**：
    *   **登录名**（进大门）：服务器级别的账号（如sa）。
    *   **用户**（进房间）：数据库级别的账号。
    *   **权限**：对表进行增删改查的权利。
---
*   **权限操作**：
    *   `GRANT` (授权)
    *   `REVOKE` (收回)
    *   `DENY` (拒绝)

## 2. 权限管理语句 (DCL)

*   **GRANT (授予)**：给权。
    *   `GRANT SELECT ON Student TO 张三;` （允许张三查询学生表）。
*   **REVOKE (收回)**：收回之前给的权（不代表拒绝，只是变回中立）。
    *   `REVOKE SELECT ON Student FROM 张三;`
*   **DENY (拒绝)**：**拉黑**。优先级最高！
    *   `DENY SELECT ON Student TO 张三;` （就算别人给了张三权限，只要有这一条，他也看不了）。

## 3. 角色 (Role)
*   **【通俗】** 角色就是**“职位”**。
*   与其给每个人单独发钥匙（麻烦），不如规定“经理”能开所有门。张三是经理，那他自然就能开门。
*   **固定服务器角色**：`sysadmin` (系统管理员，皇帝，权限最大)。
*   **固定数据库角色**：`db_owner` (数据库拥有者，在这个库里最大)。

### 5. 维护 (备份与恢复)
*   **恢复模式**：简单、完整、大容量日志。
*   **备份类型**：完整备份、差异备份、事务日志备份。
*   **分离与附加**：用于数据库的迁移 (移动 .mdf 和 .ldf 文件)。
### 2.2 分离与附加 (Detach & Attach) —— *搬家专用*
*   **场景**：你想把学校机房电脑里的数据库拷贝到自己U盘里带回家。
*   **直接复制报错？** 因为SQL Server如果不停止服务，文件是被**锁死**的。
*   **解决方法**：
    1.  **分离 (Detach)**：告诉系统“这个库我暂时不用了，你松手”。然后你就可以复制 .mdf 和 .ldf 文件了。
    2.  **附加 (Attach)**：把文件拷到家里电脑，告诉系统“我带了两个文件来，你把它认领回去”。

### 2.3 备份与还原 (Backup & Restore) —— *救命专用*
*   **恢复模式**：
    *   **简单模式**：不怎么记日志，空间省，但只能恢复到备份的那一刻。（适合开发测试）。
    *   **完整模式**：疯狂记日志，能恢复到**任意时间点**（比如恢复到昨天下午14:00:01），但日志文件会很大。（适合银行、电商）。
*   **T-SQL备份命令**（填空题常考）：
    ```sql
    BACKUP DATABASE MySchool TO DISK = 'D:\Backup\MySchool.bak';
    ```

---

# 🎯 模拟实战演练 (自我检验)

### 一、 选择题
1.  **题目**：SQL Server 的系统数据库中，必须定期备份的是（ ），否则一旦损坏系统将无法启动。
    *   A. tempdb
    *   B. model
    *   C. master
    *   D. msdb
    *   **【解析】** 选 **C**。master是大脑，坏了就瘫痪。tempdb每次重启都重置，不用备份。

2.  **题目**：若要存储学生的“自我介绍”，字数在50-500字之间浮动，最适合的数据类型是（ ）。
    *   A. char(500)
    *   B. varchar(500)
    *   C. int
    *   D. datetime
    *   **【解析】** 选 **B**。字数不固定，用变长 varchar 最节省空间。

3.  **题目**：关于安全管理，下列说法错误的是（ ）。
    *   A. sa 是系统内置的管理员账号。
    *   B. 删除登录名(Login)会自动删除对应的数据库用户(User)。
    *   C. Windows身份验证比混合模式更安全。
    *   D. DENY 权限优先于 GRANT 权限。
    *   **【解析】** 选 **B**。这是个大坑！删了进大门的卡（Login），房间里的人（User）还在，只是成了“孤儿用户”，甚至可能导致安全隐患。

### 二、 简答/操作题

**题目**：请写出 T-SQL 语句，完成以下操作：
1.  创建一个名为 `TestDB` 的数据库。
2.  在该库中建表 `T_User`，包含 `ID` (int, 主键), `Username` (varchar(20))。
3.  创建一个登录名 `guest_login`，密码为 `123456`。
4.  给它在 `TestDB` 中创建一个对应的用户 `guest_user`。
5.  授予 `guest_user` 对表 `T_User` 的查询（SELECT）权限。

**【参考答案】**：
```sql
-- 1. 建库
CREATE DATABASE TestDB;
GO

-- 2. 建表
USE TestDB;
CREATE TABLE T_User (
    ID int PRIMARY KEY,
    Username varchar(20)
);
GO

-- 3. 建登录名 (服务器级)
CREATE LOGIN guest_login WITH PASSWORD = '123456';
GO

-- 4. 建数据库用户 (数据库级，要把登录名映射进来)
USE TestDB;
CREATE USER guest_user FOR LOGIN guest_login;
GO

-- 5. 授权
GRANT SELECT ON T_User TO guest_user;
GO
```

---

### 💡 复习小贴士
1.  **分清三个文件**：mdf（主数据）、ndf（次数据）、ldf（日志）。
2.  **分清char/varchar**：身份证用char，名字用varchar。
3.  **分清Login/User**：Login是进服务器的，User是进数据库的。先有Login，再有User。

---

## 第四部分：SQL 语言 (第9章 - 核心重点)

### 1. 数据定义语言 (DDL)
*   `CREATE`, `ALTER`, `DROP`
*   `CREATE TABLE`, `DROP TABLE`, `ALTER TABLE`, `CREATE VIEW`.

### 2. 数据操纵语言 (DML)
*   **插入**：`INSERT INTO 表名 (列...) VALUES (值...)`
*   **更新**：`UPDATE 表名 SET 列=值 WHERE 条件`
*   **删除**：`DELETE FROM 表名 WHERE 条件`
*   `INSERT INTO 表名 (列1, 列2) VALUES (值1, 值2)`
*   `UPDATE 表名 SET 列=新值 WHERE 条件`
*   `DELETE FROM 表名 WHERE 条件`

### 3. 数据查询语言 (DQL) - SELECT
*   **基本结构**：
    ```sql
    SELECT [TOP n] <列名>
    FROM <表名>
    WHERE <条件>
    GROUP BY <分组列> HAVING <分组条件>
    ORDER BY <排序列> [ASC|DESC]
    ```
    
*   **分组与筛选**:
    *   `GROUP BY`: 分组。
    *   `HAVING`: 对**分组后**的结果进行筛选（必须配合GROUP BY使用）。
    *   `WHERE`: 对**原始记录**进行筛选。
*   **常用查询技巧**：
    *   **模糊查询**：`LIKE` (通配符 `%`, `_`)。
    *   `LIKE`: 模糊匹配。通配符 `%` (任意多个字符), `_` (单个字符), `[]` (范围内字符)。
        *   *例*: `[ABC]%a` 能匹配以A、B或C开头，以a结尾的字符串。
    *   **空值判断**：`IS NULL`, `IS NOT NULL`。
    *   **范围**：`BETWEEN...AND`, `IN (...)`.
    *   `BETWEEN A AND B`: 在范围内。
    *   **聚合函数**: `COUNT` (计数), `SUM` (求和), `AVG` (平均), `MAX` (最大), `MIN` (最小)。
    *   **分组**：`GROUP BY` (注意：聚合函数作为条件必须用 `HAVING`，不能用 `WHERE`)。
*   **多表连接 (JOIN)**：
    *   **内连接 (INNER JOIN)**：只返回匹配的行。
    *   **左外连接 (LEFT JOIN)**：返回左表所有行 + 右表匹配行 (无匹配则NULL)。
    *   **右外连接 (RIGHT JOIN)**：返回右表所有行 + 左表匹配行。
*   **子查询**：嵌套在 `WHERE` 中，使用 `IN`, `EXISTS`, `ANY`, `ALL` 或比较运算符。
  *   `IN ('A', 'B')`: 在列表内。

### 1. 数据定义 (DDL) - 建表
```sql
CREATE TABLE Student (
    Sno CHAR(10) PRIMARY KEY,        -- 主键
    Sname VARCHAR(20) NOT NULL,      -- 非空
    Sex CHAR(2) CHECK(Sex IN ('男','女')), -- 约束
    Age INT
);
```

### 2. 数据操纵 (DML) - 增删改
*   **插入**：`INSERT INTO Student(Sno, Sname) VALUES('001', '张三');`
*   **修改**：`UPDATE Student SET Age = 20 WHERE Sname = '张三';` （**千万别忘了WHERE，否则全改了**）
*   **删除**：`DELETE FROM Student WHERE Sno = '001';`

### 3. 数据查询 (DQL) - 查 (SELECT)
这是最复杂的，记住这个**执行顺序**：
**FROM表 $\to$ ON条件 $\to$ JOIN $\to$ WHERE筛选 $\to$ GROUP BY分组 $\to$ HAVING筛选组 $\to$ SELECT $\to$ ORDER BY排序**

**常用查询套路（背下来）：**

*   **模糊查询**：姓“张”的 $\to$ `WHERE Sname LIKE '张%'`
*   **范围查询**：年龄20到30 $\to$ `WHERE Age BETWEEN 20 AND 30`
*   **多表连接**：查询学生姓名和他的成绩
    ```sql
    SELECT Student.Sname, SC.Grade 
    FROM Student, SC 
    WHERE Student.Sno = SC.Sno;  -- 连接条件
    ```
*   **分组统计**：查询每门课的平均分
    ```sql
    SELECT Cno, AVG(Grade) 
    FROM SC 
    GROUP BY Cno;
    ```
*   **分组后筛选**：查询平均分大于80的课程（**用HAVING**）
    ```sql
    SELECT Cno 
    FROM SC 
    GROUP BY Cno 
    HAVING AVG(Grade) > 80; -- 聚合函数只能在HAVING里判断
    ```
    
---

### 4. 视图 (View)
*   **定义**：虚表，存储查询定义，不存储数据。
*   **作用**：简化查询、提高安全性 (屏蔽敏感列)、逻辑独立性。
*   语法：`CREATE VIEW 视图名 AS SELECT...`


### 1. SQL 执行顺序 (做题的黄金法则)
写SQL时，脑子里必须有这个顺序，否则 `WHERE` 和 `HAVING` 容易混淆：
1.  **FROM** (笛卡尔积、连接表)
2.  **ON** (连接条件筛选)
3.  **JOIN** (添加外部行，如Left Join)
4.  **WHERE** (筛选非聚合数据)  <-- **注意：这里不能用 Count/Sum 等聚合函数**
5.  **GROUP BY** (分组)
6.  **HAVING** (筛选聚合后的组) <-- **注意：这里才能用 Count/Sum**
7.  **SELECT** (提取列)
8.  **DISTINCT** (去重)
9.  **ORDER BY** (排序)

**书写顺序 (你写的样子)：**
```sql
1. SELECT ... 
2. FROM ... 
3. WHERE ... 
4. GROUP BY ... 
5. HAVING ... 
6. ORDER BY ...
```

**执行顺序 (电脑处理的逻辑)：**
1.  **FROM**：先找到表，把表拼在一起（如果是多表）。
2.  **WHERE**：**筛行**。把不符合条件的原始记录踢掉。
3.  **GROUP BY**：**分组**。把剩下的记录按规则捆成一捆一捆的。
4.  **HAVING**：**筛组**。把不符合条件的“捆”踢掉。
5.  **SELECT**：**挑列**。选出你要看的列，或者进行计算（如求和）。
6.  **ORDER BY**：**排队**。最后把结果整理一下顺序。

---

### 2. 复杂查询模版 (背诵)

#### 场景A：分组统计 + 筛选 (HAVING)
**题目**：查询选修了3门以上课程，且平均分大于80分的学生学号。
```sql
SELECT Sno 
FROM SC 
GROUP BY Sno 
HAVING COUNT(*) > 3 AND AVG(Grade) > 80;
```

#### 场景B：多表连接 + 自身连接
**题目**：查询与“张三”在同一个系学习的学生姓名。
```sql
/* 方法1：子查询 (推荐，逻辑简单) */
SELECT Sname FROM Student 
WHERE Dept = (SELECT Dept FROM Student WHERE Sname = '张三')
AND Sname != '张三'; -- 排除张三自己

/* 方法2：自身连接 (AS T1, AS T2) */
SELECT T1.Sname 
FROM Student AS T1, Student AS T2
WHERE T1.Dept = T2.Dept AND T2.Sname = '张三' AND T1.Sname != '张三';
```

#### 场景C：不存在 / 未选修 (NOT EXISTS / EXCEPT)
**题目**：查询没有选修“数据库”课程的学生名单。
```sql
/* 标配写法：NOT IN */
SELECT Sname FROM Student 
WHERE Sno NOT IN (
    SELECT Sno FROM SC, Course 
    WHERE SC.Cno = Course.Cno AND Course.Cname = '数据库'
);

/* 高分写法：NOT EXISTS (性能更好，老师更喜欢) */
SELECT Sname FROM Student S
WHERE NOT EXISTS (
    SELECT * FROM SC, Course C
    WHERE SC.Sno = S.Sno AND SC.Cno = C.Cno AND C.Cname = '数据库'
);
```

### 3. 数据定义与操纵 (易错点)
*   **创建表时的约束**：
    ```sql
    CREATE TABLE Student (
        Sno CHAR(10) PRIMARY KEY,       -- 主键
        Sname VARCHAR(20) NOT NULL,     -- 非空
        Sex CHAR(2) CHECK (Sex IN ('男','女')), -- 检查约束
        DeptNO CHAR(4) FOREIGN KEY REFERENCES Dept(Dno) -- 外键
    );
    ```
*   **更新操作 (带子查询)**：
    *   题目：将“计算机系”所有学生的成绩加5分。
    ```sql
    UPDATE SC SET Grade = Grade + 5
    WHERE Sno IN (SELECT Sno FROM Student WHERE Dept = 'CS');
    ```

## 第一节：单表查询 (基础内功)

### 1. 基本查询结构
*   **语法**：`SELECT [DISTINCT] <列名> FROM <表名>`
*   **解释**：
    *   `*`：代表所有列（考试时尽量写出具体列名，除非题目要求查所有）。
    *   `DISTINCT`：**去重**。比如查“有哪些系”，如果不加，会显示一堆重复的“计算机系”。

### 2. 条件筛选 (WHERE 子句) —— *漏斗*
*   **作用**：在数据分组之前，对原始数据进行过滤。
*   **常用运算符**：
    *   **比较**：`=`, `>`, `<`, `>=`, `<=`, `<>` (不等于, 有时也用 `!=`)
    *   **范围**：`BETWEEN 20 AND 30` (包含20和30，等价于 `>=20 AND <=30`)
    *   **集合**：`IN ('CS', 'IS')` (在列表里), `NOT IN`
    *   **空值**：`IS NULL` (千万别写成 `= NULL`，这是死刑！), `IS NOT NULL`
    *   **多重条件**：`AND` (并且), `OR` (或者), `NOT` (非)

### 3. 模糊查询 (LIKE) —— *找替身*
*   **语法**：`WHERE 列名 LIKE '模式串'`
*   **通配符 (必考)**：
    *   `%` (百分号)：代表**任意长度**的字符串（0个或多个字符）。
        *   `'张%'`：姓张的人（张三、张无忌、张三丰）。
        *   `'%华%'`：名字里带“华”的人。
    *   `_` (下划线)：代表**任意单个**字符。
        *   `'张_'`：姓张且名字只有两个字的人（张三）。不包含张无忌。
        *   `'__'`：两个字的名字。

### 4. 排序 (ORDER BY)
*   **语法**：`ORDER BY 列名 [ASC | DESC]`
*   **解释**：
    *   `ASC`：升序 (默认，可以不写)。
    *   `DESC`：降序 (从大到小)。
    *   **多列排序**：`ORDER BY 系号 ASC, 年龄 DESC` (先按系号排，系号一样的，按年龄从大到小排)。

---

## 第二节：聚合与分组 (数据透视)

这部分是难点，容易把 `WHERE` 和 `HAVING` 搞混。

### 1. 聚合函数 (Aggregate Functions)
这些函数是把“多行”变成“一个数”。
*   `COUNT(*)`：统计行数。
*   `SUM(列)`：求和。
*   `AVG(列)`：求平均值。
*   `MAX(列)`：求最大值。
*   `MIN(列)`：求最小值。
*   **【铁律】**：聚合函数**不能**出现在 `WHERE` 子句中！(因为WHERE在分组前执行，那时还没算出总和呢)。

### 2. 分组 (GROUP BY)
*   **含义**：把某些列值相同的行，“捆”在一起。
*   **【铁律】**：一旦用了 `GROUP BY`，`SELECT` 后面只能出现：
    1.  被分组的列 (GROUP BY 后面的列)。
    2.  聚合函数。
    *   *错误写法*：`SELECT Name, AVG(Score) FROM SC GROUP BY Sno` (按学号分组了，名字可能有多个，没法显示)。

### 3. 分组后筛选 (HAVING)
*   **含义**：对“捆”好后的组进行筛选。
*   **WHERE vs HAVING (考试必考区别)**：
    *   `WHERE`：管**个体**。在分组**前**筛选。不能跟聚合函数。
    *   `HAVING`：管**团体**。在分组**后**筛选。通常跟聚合函数。

---

## 第三节：连接查询 (多表联动)

考试大题通常需要从两个以上的表中拿数据，这时必须用连接。

假设有两张表：
*   **Student** (Sno, Name, Dept)
*   **SC** (Sno, Cno, Grade)

### 1. 内连接 (INNER JOIN) —— *找交集*
*   **含义**：只保留两个表中**都有**的数据。
*   **旧式写法 (隐式)**：
    ```sql
    SELECT S.Name, C.Grade 
    FROM Student S, SC C 
    WHERE S.Sno = C.Sno; -- 连接条件写在WHERE里
    ```
*   **标准写法 (推荐)**：
    ```sql
    SELECT S.Name, C.Grade
    FROM Student S
    INNER JOIN SC C ON S.Sno = C.Sno; -- 连接条件写在ON里，逻辑更清晰
    ```

### 2. 外连接 (OUTER JOIN) —— *保全一方*
*   **左外连接 (LEFT JOIN)**：保证**左边表**的数据全都在，右边对不上的填NULL。
    *   *场景*：列出所有学生及其成绩，哪怕这个学生没选课（成绩显NULL），也要把学生列出来。
    ```sql
    SELECT S.Name, C.Grade
    FROM Student S
    LEFT JOIN SC C ON S.Sno = C.Sno;
    ```
*   **右外连接 (RIGHT JOIN)**：同理，保全右边的表。

---

## 第四节：嵌套查询 (套娃战术)

一个查询的结果，作为另一个查询的条件。

### 1. IN 子查询
*   **场景**：查询选修了“数据库”课程的学生学号。
*   **思路**：先在课程表找“数据库”的课号 $\to$ 再在选课表找选了这个号的人。
```sql
SELECT Sno 
FROM SC 
WHERE Cno IN (
    SELECT Cno FROM Course WHERE Cname = '数据库'
);
```

### 2. EXISTS 子查询 (难点，高性能)
*   **含义**：`EXISTS` 不返回数据，只返回 `True/False`。只要子查询里能查到哪怕一条记录，就返回True。
*   **场景**：查询选修了所有课程的学生（双重否定法：不存在一门课他没选）。
*   **模板**：`NOT EXISTS ( ... NOT EXISTS ... )` （这是高分题的考法，理解起来较难，建议先掌握 IN）。

---

# 🏆 考试实战例题集 (必练)

假设有以下三张表：
*   **学生表 Student**: `Sno` (学号), `Sname` (姓名), `Sage` (年龄), `Sdept` (系别)
*   **课程表 Course**: `Cno` (课号), `Cname` (课名), `Credit` (学分)
*   **选课表 SC**: `Sno` (学号), `Cno` (课号), `Grade` (成绩)

### 例题 1：基础筛选
**题目**：查询“计算机系(CS)”年龄在20岁以下的学生的姓名和学号。
**SQL**：
```sql
SELECT Sname, Sno 
FROM Student 
WHERE Sdept = 'CS' AND Sage < 20;
```

### 例题 2：模糊查询
**题目**：查询所有姓“刘”的学生的记录。
**SQL**：
```sql
SELECT * 
FROM Student 
WHERE Sname LIKE '刘%';
```

### 例题 3：多表连接 + 排序
**题目**：查询选修了“数据库”课程的学生的学号、姓名和成绩，并按成绩降序排列。
**SQL**：
```sql
SELECT S.Sno, S.Sname, SC.Grade
FROM Student S
JOIN SC ON S.Sno = SC.Sno
JOIN Course C ON SC.Cno = C.Cno
WHERE C.Cname = '数据库'
ORDER BY SC.Grade DESC;
```
*(注：这里用了三表连接，逻辑非常清晰：人连选课，选课连课名)*

### 例题 4：分组 + 聚合 + 筛选 (HAVING) —— *高频考点*
**题目**：查询选修了 3 门以上课程，且平均成绩及格（>=60）的学生学号。
**SQL**：
```sql
SELECT Sno
FROM SC
GROUP BY Sno             -- 按学号把成绩捆起来
HAVING COUNT(*) > 3      -- 筛选：这捆里的数量大于3
   AND AVG(Grade) >= 60; -- 筛选：这捆的平均分及格
```

### 例题 5：子查询 (更新数据)
**题目**：将“计算机系”所有学生的成绩加 5 分。
**SQL**：
```sql
UPDATE SC 
SET Grade = Grade + 5
WHERE Sno IN (
    SELECT Sno FROM Student WHERE Sdept = 'CS'
);
```
*(注：UPDATE只能改一张表，所以必须用子查询找到计算机系的学生ID)*

---

# 📝 考前记忆口诀
1.  **查谁写谁**：`SELECT` 后面跟你要展示的列。
2.  **从哪查**：`FROM` 后面跟表名。
3.  **啥条件**：`WHERE` 后面跟过滤条件（不能带函数）。
4.  **怎么组**：`GROUP BY` 后面跟分组列。
5.  **组条件**：`HAVING` 后面跟聚合函数（如 `COUNT>1`）。
6.  **怎么排**：`ORDER BY` 放在最后面。
7.  **空值坑**：判断空值必须用 `IS NULL`，千万别用 `= NULL`。

---

---

## 第五部分：数据库开发技术 - ADO.NET (第13-14章)

## 第六章：ADO.NET 程序设计 (编程题核心)
**1. 体系结构**
*   **Data Provider (数据提供程序)**: 包括 Connection, Command, DataReader, DataAdapter。
*   **DataSet (数据集)**: 内存中的数据库副本，断开式连接的核心。

**2. 核心对象与方法**
*   **SqlConnection**: 连接数据库。
    *   方法: `Open()`, `Close()`
*   **SqlCommand**: 执行SQL语句。
    *   属性: `Connection`, `CommandText`.
    *   方法:
        *   `ExecuteNonQuery()`: 执行增删改 (INSERT, UPDATE, DELETE)，返回**受影响行数**。
        *   `ExecuteScalar()`: 执行查询，返回**结果集第一行第一列** (常用于COUNT, SUM)。
        *   `ExecuteReader()`: 返回 `SqlDataReader` 对象，用于快速向前只读读取数据。
*   **SqlDataAdapter**: 数据适配器，连接 DataSet 和 Database 的桥梁。
    *   方法: `Fill(dataset, "tablename")` (填充数据), `Update()` (更新回数据库)。
*   **SqlDataReader**: 只读、向前的数据流。
    *   方法: `Read()` (读取下一行)。

**3. 异常处理**
*   结构: `try { ... } catch { ... } finally { ... }`
*   `finally` 块中的代码无论是否发生异常都会执行（常用于关闭数据库连接）。

### 1. ADO.NET 架构
*   **.NET Data Provider (数据提供程序)**：连接数据库的组件。
    *   `Connection`：建立连接。
    *   `Command`：执行SQL命令 (增删改查)。
    *   `DataReader`：**只读、只进**的数据流 (在线模式)。
    *   `DataAdapter`：**桥梁**，填充DataSet和更新数据库。
*   **DataSet (数据集)**：
    *   **离线模式** (断开式) 的核心。
    *   内存中的数据库副本，包含 `DataTable`, `DataRow`, `DataColumn`。

### 2. 核心类与命名空间
*   命名空间：`System.Data.SqlClient` (针对SQL Server)。
*   **SqlConnection**：
    *   属性：`ConnectionString` (包含Data Source, Initial Catalog, User ID, Password)。
    *   方法：`Open()`, `Close()`。
*   **SqlCommand**：
    *   属性：`CommandText` (SQL语句), `Connection`。
    *   方法：
        *   `ExecuteReader()`: 返回 `SqlDataReader` (用于SELECT)。
        *   `ExecuteNonQuery()`: 返回受影响行数 (用于INSERT/UPDATE/DELETE)。
        *   `ExecuteScalar()`: 返回第一行第一列 (用于聚合查询如COUNT)。
*   **SqlDataAdapter**：
    *   方法：`Fill()` (填充DataSet), `Update()` (提交更改回数据库)。

### 3. 数据绑定
*   **简单绑定**：绑定单个值到控件属性 (如 TextBox, Label)。
    *   `textBox1.DataBindings.Add(...)`
*   **复杂绑定**：绑定列表数据 (如 DataGridView, ComboBox)。
    *   `dataGridView1.DataSource = myDataSet.Tables[0];`
*   **BindingSource**：作为数据源与控件之间的中间层，提供导航功能。


# 第五部分：编程开发篇——ADO.NET 怎么写代码
**(对应第13-14章：ADO.NET)**

这是C#程序连接数据库的技术，考试通常考填空或简答代码段。

### 1. 五大金刚（核心对象）
1.  **Connection** (SqlConnection)：**电话线**。负责建立连接。
2.  **Command** (SqlCommand)：**话筒**。负责发送SQL命令。
3.  **DataReader** (SqlDataReader)：**只读数据流**。在线读取，速度快，只能一条条往下读，读取时连接必须打开。
4.  **DataAdapter** (SqlDataAdapter)：**卡车**。负责把数据从数据库拉回来，或者运回去。
5.  **DataSet** (数据集)：**自家仓库**。离线内存数据库，断开连接后数据还在这里，可以随意操作。

### 2. 必背代码段
**场景一：执行增/删/改 (ExecuteNonQuery)**
```csharp
// 1. 连
SqlConnection conn = new SqlConnection("连接字符串...");
conn.Open();
// 2. 命令
string sql = "DELETE FROM Student WHERE Sno='001'";
SqlCommand cmd = new SqlCommand(sql, conn);
// 3. 执行 (返回受影响行数)
int rows = cmd.ExecuteNonQuery(); 
// 4. 关
conn.Close();
```

**场景二：离线查询 (DataAdapter + DataSet)**
```csharp
SqlConnection conn = new SqlConnection("...");
string sql = "SELECT * FROM Student";
// 卡车装好命令和连接
SqlDataAdapter da = new SqlDataAdapter(sql, conn);
// 准备仓库
DataSet ds = new DataSet();
// 拉货进仓库 (自动打开和关闭连接)
da.Fill(ds, "StuTable"); 
// 绑到界面控件
dataGridView1.DataSource = ds.Tables["StuTable"];
```

---

# 💡 终极复习策略（如何拿优异成绩）

1.  **攻克理论选择题**：重点复习第一部分的**三级模式**、**E-R图**、**完整性约束**。
2.  **拿下SQL大题**：找几道复杂的SQL题（含GROUP BY和多表连接的），手写几遍，不要只看。
3.  **搞定设计题**：练习画E-R图，并练习把它转成表结构（特别是多对多关系要拆成三张表）。
4.  **背诵代码填空**：把第五部分的 Connection, Command, DataAdapter, DataSet 的单词拼写和用法背下来。



# 第13-14章：ADO.NET 核心编程指南

## 一、 核心概念：ADO.NET 是什么？
简单来说，ADO.NET 就是 C# 程序用来**连接、读取、操作**数据库的一组类库。
想象一下：
*   你的 C# 程序是**“家”**。
*   SQL Server 数据库是**“超市”**。
*   ADO.NET 就是**“路”和“交通工具”**。

在写代码前，必须先引入命名空间（相当于拿到了车钥匙）：
```csharp
using System.Data;
using System.Data.SqlClient; // 针对SQL Server的专用工具包
```

---

## 二、 五大核心对象 (必须死记硬背)

这五个对象是 ADO.NET 的“五虎上将”，考试必考！

| 对象名 | 类名 (C#) | 通俗解释 | 核心作用 |
| :--- | :--- | :--- | :--- |
| **Connection** | `SqlConnection` | **电话线** | 建立程序与数据库的物理连接。 |
| **Command** | `SqlCommand` | **话筒/指令** | 发送 SQL 语句（增删改查）给数据库。 |
| **DataReader** | `SqlDataReader` | **自来水管** | **在线模式**。只读、只进、速度快。像流水一样读数据。 |
| **DataAdapter** | `SqlDataAdapter` | **卡车** | **离线模式**。负责把数据拉回来填满仓库，或者把仓库的改动运回去。 |
| **DataSet** | `DataSet` | **自家仓库** | **离线模式**。内存中的临时数据库，断网也能用。 |

---

## 三、 核心语法与代码模版 (背下来就能得分)

考试通常考查三种场景：**执行增删改**、**读取单值**、**读取列表**。

### 场景 1：执行增、删、改 (最常考)
**核心方法**：`ExecuteNonQuery()`
**返回值**：受影响的行数 (int)。比如删了1行，返回1。

**【通用代码模版】**
```csharp
// 1. 定义连接字符串 (考试通常会给，或者写 Data Source=.;...)
string connString = "Data Source=.;Initial Catalog=MySchool;Integrated Security=True";

// 2. 创建连接对象
SqlConnection conn = new SqlConnection(connString);

try {
    // 3. 打开连接 (一定要记得开！)
    conn.Open();

    // 4. 定义SQL语句 (建议使用参数化查询，防止注入，也更专业)
    string sql = "INSERT INTO Student (Sno, Sname) VALUES (@sno, @name)";

    // 5. 创建命令对象
    SqlCommand cmd = new SqlCommand(sql, conn);

    // 6. 填充参数 (如果是拼字符串，这步省略，但强烈建议用参数)
    cmd.Parameters.AddWithValue("@sno", "2023001");
    cmd.Parameters.AddWithValue("@name", "张三");

    // 7. ★★★ 执行命令 (这是最关键的一步)
    int rows = cmd.ExecuteNonQuery();

    if (rows > 0) {
        Console.WriteLine("操作成功！");
    }
}
catch (Exception ex) {
    Console.WriteLine("出错了：" + ex.Message);
}
finally {
    // 8. 关闭连接 (一定要记得关！放在finally里最安全)
    conn.Close();
}
```

---

### 场景 2：查询单个值 (如登录验证、查总数)
**核心方法**：`ExecuteScalar()`
**返回值**：结果集中第一行第一列的值 (object)。需要强制转换类型。

**【通用代码模版】**
```csharp
// 前面的连接步骤省略...
conn.Open();

string sql = "SELECT COUNT(*) FROM Student"; // 查询学生总数
SqlCommand cmd = new SqlCommand(sql, conn);

// ★★★ 执行并获取首个值
// 因为返回是object，如果是数字要转(int)，是字符串要转.ToString()
int count = (int)cmd.ExecuteScalar(); 

Console.WriteLine("学生总数：" + count);

conn.Close();
```

---

### 场景 3：查询多行数据 (在线模式 vs 离线模式)

#### 方式 A：在线读取 (DataReader) —— 速度快，省内存
**核心方法**：`ExecuteReader()`，`Read()`
**特点**：连接必须一直开着，用完必须手动关闭 Reader。

```csharp
// 前面的连接步骤省略...
conn.Open();
string sql = "SELECT Sno, Sname FROM Student";
SqlCommand cmd = new SqlCommand(sql, conn);

// 1. 获取读取器
SqlDataReader reader = cmd.ExecuteReader();

// 2. 循环读取 (Read()返回true表示还有下一行)
while (reader.Read()) {
    // 3. 读数据：可以通过列名，也可以通过索引(0, 1)
    string sno = reader["Sno"].ToString();
    string name = reader["Sname"].ToString();
    Console.WriteLine(sno + " - " + name);
}

// 4. 必须先关Reader，再关Connection
reader.Close();
conn.Close();
```

#### 方式 B：离线读取 (DataAdapter + DataSet) —— 适合绑定控件
**核心方法**：`Fill()`
**特点**：一次性把数据拉到内存，自动开关连接，适合绑定到 DataGridView。

```csharp
string connString = "...";
string sql = "SELECT * FROM Student";

// 1. 创建卡车 (DataAdapter)，它会自动处理连接和命令
SqlDataAdapter da = new SqlDataAdapter(sql, connString);

// 2. 创建仓库 (DataSet)
DataSet ds = new DataSet();

// 3. ★★★ 拉货 (Fill方法会自动Open连接，取数据，Close连接)
da.Fill(ds, "StuTable"); // "StuTable" 是给内存里的表起的别名

// 4. 数据已经在 ds 里了，可以随便用
// 例如：绑定到界面上的表格控件
// dataGridView1.DataSource = ds.Tables["StuTable"];
```

---

## 四、 必考知识点对比 (易混淆)

1.  **ExecuteNonQuery vs ExecuteScalar vs ExecuteReader**
    *   `ExecuteNonQuery`: 用于 **增、删、改**。返回 **受影响行数**。
    *   `ExecuteScalar`: 用于 **查单个值** (如Count)。返回 **第一行第一列**。
    *   `ExecuteReader`: 用于 **查列表**。返回 **DataReader对象**。

2.  **DataReader vs DataSet**
    *   **DataReader**: 在线，一次读一行，快，轻量级。 (像看流媒体视频)。
    *   **DataSet**: 离线，把数据全存在内存，功能多，占内存。 (像下载视频看)。

---

## 五、 模拟编程题 (实战演练)

**题目：**
编写一个 C# 方法 `AddStudent`，接收学号和姓名作为参数，将其插入到数据库 `SchoolDB` 的 `Student` 表中。
要求：使用参数化查询，并处理异常。

**【参考满分答案】**
```csharp
// 引入命名空间
using System;
using System.Data.SqlClient;

public void AddStudent(string sno, string sname)
{
    // 1. 连接字符串
    string connStr = "Data Source=.;Initial Catalog=SchoolDB;Integrated Security=True";
    
    // 2. 创建连接
    SqlConnection conn = new SqlConnection(connStr);
    
    try
    {
        conn.Open(); // 打开连接
        
        // 3. 编写带参数的SQL
        string sql = "INSERT INTO Student(Sno, Sname) VALUES(@id, @name)";
        
        // 4. 创建命令
        SqlCommand cmd = new SqlCommand(sql, conn);
        
        // 5. 添加参数 (防止SQL注入)
        cmd.Parameters.AddWithValue("@id", sno);
        cmd.Parameters.AddWithValue("@name", sname);
        
        // 6. 执行 (增删改用ExecuteNonQuery)
        int result = cmd.ExecuteNonQuery();
        
        if (result > 0)
        {
            Console.WriteLine("添加成功！");
        }
    }
    catch (Exception ex)
    {
        Console.WriteLine("发生错误：" + ex.Message);
    }
    finally
    {
        // 7. 确保关闭连接
        conn.Close();
    }
}
```

**题目：**
使用 `SqlDataAdapter` 查询所有学生信息，并将其绑定到名为 `dgvStudents` 的 DataGridView 控件上。

**【参考满分答案】**
```csharp
public void LoadData()
{
    string connStr = "Data Source=.;Initial Catalog=SchoolDB;Integrated Security=True";
    string sql = "SELECT * FROM Student";
    
    // 1. 创建适配器
    SqlDataAdapter da = new SqlDataAdapter(sql, connStr);
    
    // 2. 创建数据集
    DataSet ds = new DataSet();
    
    // 3. 填充数据 (不需要手动Open/Close)
    da.Fill(ds, "TempTable");
    
    // 4. 绑定数据源
    dgvStudents.DataSource = ds.Tables["TempTable"];
}
```

---

### 💡 拿分秘籍
1.  **拼写不要错**：`SqlConnection` 不是 `SQLConnection` (注意大小写)。
2.  **记得开关门**：用了 `Open()` 就一定要在 `finally` 里 `Close()`。
3.  **选对方法**：
    *   改数据 $\to$ `ExecuteNonQuery`
    *   查一个数 $\to$ `ExecuteScalar`
    *   查列表 $\to$ `Fill` (最省事) 或 `ExecuteReader`。



## 🚀 第三模块：ADO.NET 程序设计 (编程题/填空题)

这部分是拿分的关键，代码结构是固定的，请务必**默写**以下几个核心对象的用法。

### 1. 五大核心对象 (必须死记硬背)
1.  **Connection** (SqlConnection): 建立物理连接。
2.  **Command** (SqlCommand): 执行SQL语句（增删改查）。
3.  **DataReader** (SqlDataReader): **只读、只进**、在线读取数据（速度快，但在读取时连接一直被占用）。
4.  **DataAdapter** (SqlDataAdapter): 桥梁，负责填充DataSet和更新数据库。
5.  **DataSet**: **离线**内存数据库，包含DataTable。

### 2. 核心代码模版

#### 模版A：使用 ExecuteNonQuery (增、删、改)
适用于：INSERT, UPDATE, DELETE。返回受影响的行数（int）。

```csharp
// 1. 定义连接字符串 (考试时通常会给出，或者写 Data Source=.;...)
string connStr = "Data Source=.;Initial Catalog=MyDB;Integrated Security=True";

// 2. 创建连接 (使用 using 语句可自动关闭连接，是加分项)
using (SqlConnection conn = new SqlConnection(connStr)) 
{
    conn.Open(); // 必须显式打开！
    
    // 3. 定义SQL (注意字符串拼接的引号)
    string sql = "DELETE FROM Student WHERE Sno = '2024001'";
    
    // 4. 创建命令对象
    SqlCommand cmd = new SqlCommand(sql, conn);
    
    // 5. 执行并返回影响行数
    int rows = cmd.ExecuteNonQuery(); 
    
    if (rows > 0) Console.WriteLine("删除成功");
}
```

#### 模版B：使用 ExecuteScalar (查询单个值)
适用于：SELECT COUNT(*), SELECT Max(Grade) 等只返回一个结果的。

```csharp
string sql = "SELECT COUNT(*) FROM Student";
SqlCommand cmd = new SqlCommand(sql, conn);
// 必须强转，因为返回是 object
int count = (int)cmd.ExecuteScalar(); 
```

#### 模版C：使用 DataReader (查询列表 - 在线模式)
适用于：需要遍历读取大量数据，且不需要修改。

```csharp
string sql = "SELECT Sno, Sname FROM Student";
SqlCommand cmd = new SqlCommand(sql, conn);

// 得到 Reader，注意：此时连接被占用
SqlDataReader reader = cmd.ExecuteReader();

// Read() 返回 true 表示还有下一行
while (reader.Read()) 
{
    // 通过列名或索引获取
    string sno = reader["Sno"].ToString();
    string name = reader[1].ToString();
}
reader.Close(); // 必须手动关闭 Reader
```

#### 模版D：使用 DataAdapter + DataSet (查询列表 - 离线模式)
适用于：需要将数据绑定到 DataGridView，或者需要断开连接后操作数据。

```csharp
string sql = "SELECT * FROM Student";
// DataAdapter 构造时传入 SQL 和 连接对象
SqlDataAdapter da = new SqlDataAdapter(sql, conn);

DataSet ds = new DataSet();

// Fill 方法自动打开连接、获取数据、填充DataSet、关闭连接
da.Fill(ds, "StuTable"); // "StuTable" 是给内存中的表起的别名

// 绑定到控件 (常考填空)
dataGridView1.DataSource = ds.Tables["StuTable"];
```


---

## 考试重点提示 (Cheat Sheet)

1.  **E-R图绘制与转换**：特别是多对多关系转换为关系模式时，需要把联系转成一张独立表。
2.  **SQL语句编写**：
    *   复杂查询：连接查询 (JOIN) 和 分组统计 (GROUP BY ... HAVING)。
    *   数据更新：INSERT, UPDATE, DELETE 的基本语法。
3.  **理论概念**：主键、外键的定义；实体完整性与参照完整性的区别；三级模式结构。
4.  **ADO.NET编程**：
    *   `DataReader` 与 `DataSet` 的区别 (在线 vs 离线)。
    *   `ExecuteScalar` 与 `ExecuteNonQuery` 的用途区别。
    *   编写简单的C#代码连接数据库并查询数据。






---

# 第二部分：模拟试题集（附答案）

## 一、选择题（每题 2 分）

1.  数据库系统（DBS）的核心软件是（ ）。
    A. 数据模型  B. 数据库管理系统 (DBMS)  C. 数据库 (DB)  D. 数据库管理员 (DBA)
2.  SQL Server 数据库的主数据文件扩展名默认为（ ）。
    A. .sql  B. .ldf  C. .mdf  D. .ndf
3.  在 E-R 图中，用来表示实体的图形是（ ）。
    A. 矩形  B. 椭圆形  C. 菱形  D. 三角形
4.  SQL 语言中，`DELETE` 语句用于（ ）。
    A. 删除表结构  B. 删除表中的记录  C. 删除数据库  D. 删除索引
5.  若要查询名字中第二个字符为“A”的学生，WHERE 子句应写为（ ）。
    A. Name LIKE '_A%'  B. Name LIKE '%A%'  C. Name LIKE 'A_%'  D. Name LIKE '?A*'
6.  在 ADO.NET 中，用于在断开连接的环境下存储数据，被称作“内存数据库”的对象是（ ）。
    A. DataReader  B. DataSet  C. Command  D. Connection
7.  执行 `SELECT COUNT(*) FROM Students` 语句，最适合使用 Command 对象的（ ）方法。
    A. ExecuteNonQuery  B. ExecuteReader  C. ExecuteScalar  D. ExecuteXmlReader
8.  下列关于视图（View）的说法，错误的是（ ）。
    A. 视图是虚表，不存储数据  B. 视图可以简化复杂查询
    C. 视图可以提高安全性      D. 修改视图定义一定会修改物理表数据
9.  事务的原子性是指（ ）。
    A. 事务中包括的所有操作要么都做，要么都不做
    B. 事务一旦提交，对数据库的改变是永久的
    C. 一个事务内部的操作对其他事务是隔离的
    D. 事务必须是使数据库从一个一致性状态变到另一个一致性状态
10. C# 代码中 `finally` 代码块的作用是（ ）。
    A. 仅在发生异常时执行  B. 仅在不发生异常时执行
    C. 无论是否发生异常都执行  D. 用于抛出异常

## 二、填空题（每空 1 分）

1.  关系数据库中的一行称为一个__________，一列称为一个__________。
2.  SQL Server 的四个系统数据库分别是 master、model、msdb 和 __________。
3.  在 SQL 中，用于对查询结果进行排序的子句是 __________，用于分组的子句是 __________。
4.  E-R 图中的菱形框表示 __________，椭圆框表示 __________。
5.  ADO.NET 中，要从数据库读取数据并填充到 DataSet 中，需要使用 __________ 对象。
6.  SQL 语句 `SELECT * FROM Stu WHERE Age BETWEEN 20 AND 25` 的含义是查询年龄在 ______ 到 ______ 之间的学生（包含边界值）。
7.  保证数据库中不包含重复元组的约束是 __________ 完整性。

## 三、设计与编程题

**1. SQL 语句编写**
设有学生表 `Student(Sno, Sname, Sex, Age, Dept)`，课程表 `Course(Cno, Cname, Credit)`，选课表 `SC(Sno, Cno, Grade)`。
(1) 查询“计算机系”所有学生的名单。
(2) 查询选修了“数据库”课程且成绩在80分以上的学生学号和姓名。
(3) 统计每门课程的选修人数，要求输出课程号和人数。
(4) 将学号为“2024001”的学生的“数据库”成绩改为 90 分。

**2. ADO.NET 程序填空**
功能：点击按钮，查询 `Student` 表中所有女生的信息，并绑定到 DataGridView 显示。

```csharp
private void btnQuery_Click(object sender, EventArgs e)
{
    // 1. 定义连接字符串
    string connString = "Data Source=.;Initial Catalog=SchoolDB;Integrated Security=True";
    
    // 2. 创建连接对象
    SqlConnection conn = new __(1)__(connString);
    
    try
    {
        // 3. 打开连接
        conn.__(2)__();
        
        // 4. 定义SQL语句
        string sql = "SELECT * FROM Student WHERE Sex = '女'";
        
        // 5. 创建适配器对象
        SqlDataAdapter da = new __(3)__(sql, conn);
        
        // 6. 创建数据集对象
        DataSet ds = new __(4)__();
        
        // 7. 填充数据
        da.__(5)__(ds, "StuTable");
        
        // 8. 绑定数据源
        dataGridView1.DataSource = ds.Tables["StuTable"];
    }
    catch (Exception ex)
    {
        MessageBox.Show(ex.Message);
    }
    finally
    {
        // 9. 关闭连接
        conn.__(6)__();
    }
}
```

---

# 模拟试题参考答案

## 一、选择题
1. B  2. C  3. A  4. B  5. A
6. B  7. C  8. D  9. A  10. C

## 二、填空题
1.  元组（或记录）、属性（或字段）
2.  tempdb
3.  ORDER BY、GROUP BY
4.  联系、属性
5.  DataAdapter
6.  20、25
7.  实体

## 三、设计与编程题

**1. SQL 语句**
(1) `SELECT Sname FROM Student WHERE Dept = '计算机系';`
(2)
```sql
SELECT Student.Sno, Student.Sname 
FROM Student, Course, SC 
WHERE Student.Sno = SC.Sno AND Course.Cno = SC.Cno 
AND Course.Cname = '数据库' AND SC.Grade > 80;
```
(3) `SELECT Cno, COUNT(*) FROM SC GROUP BY Cno;`
(4) 
```sql
UPDATE SC SET Grade = 90 
WHERE Sno = '2024001' 
AND Cno IN (SELECT Cno FROM Course WHERE Cname = '数据库');
```

**2. ADO.NET 程序填空**
(1) `SqlConnection`
(2) `Open`
(3) `SqlDataAdapter`
(4) `DataSet`
(5) `Fill`
(6) `Close`













## 🚀 第五模块：高难度模拟题及全解 (冲刺90分)

这份试题模拟了考试中可能出现的**陷阱题**和**综合题**。

### 一、 易错选择题
1.  **关于视图，下列说法正确的是？**
    A. 视图中存储了数据，查询速度快。
    B. 视图定义保存在数据库中，但数据在查询时动态生成。
    C. 对所有视图都可以进行 UPDATE 操作。
    D. 视图只能建立在基本表上，不能建立在视图上。
    *   **答案**：B
    *   *解析*：A错，视图不存数据（物化视图除外）；C错，聚合函数、DISTINCT等视图不可更新；D错，视图可以嵌套。

2.  **事务日志文件（.ldf）的作用是什么？**
    A. 存储数据库的表结构。
    B. 存储数据库的查询结果。
    C. 用于数据库的恢复 (Recovery)。
    D. 用于提高查询速度。
    *   **答案**：C
    *   *解析*：日志记录所有修改操作，用于回滚或灾难恢复。

3.  **执行 `DELETE FROM Student` 语句后：**
    A. 表结构被删除。
    B. 表中数据清空，但表结构保留，日志记录该操作。
    C. 表中数据清空，不记录日志（速度快）。
    D. 释放表所占用的空间给操作系统。
    *   **答案**：B
    *   *辨析*：`DROP TABLE` 删除表结构；`TRUNCATE TABLE` 清空数据且不记日志（速度快，不可回滚）；`DELETE` 是逐行删除并记日志。

### 二、 综合填空题
1.  在 SQL Server 中，用于定义存储过程的关键字是 `________`，用于定义触发器的关键字是 `________`。
    *   *答案*：`CREATE PROCEDURE`，`CREATE TRIGGER`
2.  数据库的并发控制主要通过 `________` 机制实现，如果两个事务互相等待对方释放资源，会造成 `________` 现象。
    *   *答案*：封锁 (Locking)，死锁 (Deadlock)
3.  ADO.NET 中，为了将 DataSet 中的更改保存回数据库，应调用 DataAdapter 的 `________` 方法。
    *   *答案*：`Update` （*注意：Fill 是读，Update 是写*）

### 三、 深度编程题 (必看)

**题目**：
现有一个成绩表 `Score(Sno, Cno, Degree)`。请编写一段 C# (ADO.NET) 代码，实现以下功能：
1.  使用事务 (Transaction) 处理。
2.  将所有低于 60 分的成绩改为 60 分。
3.  如果修改的行数超过 10 行，则**回滚**事务，取消修改；否则**提交**事务。

**参考代码 (满分模版)**：
```csharp
string connStr = "Data Source=.;Initial Catalog=MySchool;Integrated Security=True";

using (SqlConnection conn = new SqlConnection(connStr))
{
    conn.Open();
    // 1. 开启事务
    SqlTransaction trans = conn.BeginTransaction();

    // 2. 将事务关联到 Command
    SqlCommand cmd = new SqlCommand();
    cmd.Connection = conn;
    cmd.Transaction = trans; // 关键点！必须绑定事务

    try
    {
        cmd.CommandText = "UPDATE Score SET Degree = 60 WHERE Degree < 60";
        
        // 执行并获取受影响行数
        int rows = cmd.ExecuteNonQuery();

        if (rows > 10)
        {
            // 3. 回滚
            trans.Rollback();
            Console.WriteLine("修改行数过多，已取消操作。");
        }
        else
        {
            // 4. 提交
            trans.Commit();
            Console.WriteLine("修改成功。");
        }
    }
    catch (Exception ex)
    {
        // 发生异常必须回滚
        trans.Rollback();
        Console.WriteLine("发生错误：" + ex.Message);
    }
}
```

### 四、 复杂 SQL 设计题
**题目**：
有两个表：`Employee(EmpID, Name, Salary, DeptID)` 和 `Department(DeptID, DeptName)`。
请写出 SQL 语句：查询**平均工资最高**的部门名称及其平均工资。

**解题思路**：
这是典型的“聚合 + 排序 + 限制”组合拳，或者是“子查询”考点。

**写法一 (SQL Server TOP写法 —— 推荐)**：
```sql
SELECT TOP 1 D.DeptName, AVG(E.Salary) AS AvgSalary
FROM Employee E
JOIN Department D ON E.DeptID = D.DeptID
GROUP BY D.DeptName       -- 按部门分组
ORDER BY AvgSalary DESC;  -- 按平均工资降序排列，取第一名
```

**写法二 (标准 SQL 子查询写法 —— 应对理论考试)**：
```sql
SELECT DeptName, AVG(Salary)
FROM Employee E, Department D
WHERE E.DeptID = D.DeptID
GROUP BY DeptName
HAVING AVG(Salary) >= ALL ( -- 比所有其他部门的平均工资都大（或相等）
    SELECT AVG(Salary) 
    FROM Employee 
    GROUP BY DeptID
);
```

---

## 🏆 考前最后一小时“救命”清单

1.  **默写连接字符串**：`Data Source=...; Initial Catalog=...; User ID=...; Password=...`
2.  **默写 E-R 图三要素**：矩形(实体)、椭圆(属性)、菱形(联系)。
3.  **分清 SQL 动词**：
    *   DDL (定义): CREATE, DROP, ALTER
    *   DML (操纵): INSERT, UPDATE, DELETE
    *   DQL (查询): SELECT
    *   DCL (控制): GRANT, REVOKE
4.  **ADO.NET 口诀**：
    *   读数据：Connection -> Command -> DataReader (在线) / DataAdapter (离线)
    *   写数据：Command -> ExecuteNonQuery / DataAdapter -> Update
5.  **范式判断**：1NF(无重复列) $\to$ 2NF(无部分依赖) $\to$ 3NF(无传递依赖)。
